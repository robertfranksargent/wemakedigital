package com.wemakedigital.state.model{	import com.wemakedigital.log.Log;	import com.wemakedigital.state.controller.StateEventCommand;	import com.wemakedigital.state.controller.StateResponderCommand;	import com.wemakedigital.state.view.IStateResponder;		import org.puremvc.as3.multicore.interfaces.IProxy;	import org.puremvc.as3.multicore.patterns.proxy.Proxy;		/**	 * The StateProxy state machine is responsible for maintaining application state.	 */	public class StateProxy extends Proxy implements IProxy 	{			//----------------------------------------------------------------------		//		//  Constants		//		//----------------------------------------------------------------------				/**		 * Defines the name of the Proxy.		 */		public static const NAME : String = "StateProxy" ;		/**		 * Notification sent when a state event is successfully called.		 */		public static const EVENT_CALLED : String = "StateProxy.EVENT_CALLED";				/**		 * Notification sent when a state event error occurs.		 */		public static const EVENT_ERROR : String = "StateProxy.EVENT_ERROR" ;				/**		 * Notification sent when a state event has completed.		 */		public static const EVENT_COMPLETE : String = "StateProxy.EVENT_COMPLETE";		/**		 * Type sent with state notification by a state responder adding it as a 		 * responder to changes in the state.		 */		public static const ADD_RESPONDER : String = "StateProxy.ADD_RESPONDER";		/**		 * Type sent with state notification by a state responder removing it as 		 * a responder to changes in the state.		 */		public static const REMOVE_RESPONDER : String = "StateProxy.REMOVE_RESPONDER";		/**		 * Type sent with state notification by the state proxy instructing all 		 * responders to exit the state.		 */		public static const EXIT : String = "StateProxy.EXIT";		/**		 * Type sent with state notification by a state responder informing the 		 * state proxy that is has exited the state.		 */		public static const EXIT_RESPONSE : String = "StateProxy.EXIT_RESPONSE";		/**		 * Type sent with state notification by the state proxy instructing all 		 * responders to enter the state.		 */		public static const ENTER : String = "StateProxy.ENTER";				/**		 * Type sent with state notification by a state responder informing the 		 * state proxy that is has entered the state.		 */		public static const ENTER_RESPONSE : String = "StateProxy.ENTER_RESPONSE";		//----------------------------------------------------------------------		//		//  Variables		//		//----------------------------------------------------------------------						/**		 * Map of States objects by name.		 */		private var states : Object;		/**		 * The initial state of the StateProxy.		 */		private var initialState : State;		/**		 * The initial state of the StateProxy.		 */		private var currentState : State;		/**		 * Set to true when the state proxy is waiting for an asynchronous 		 * response from conditions, actions or responders. 		 */		private var busy : Boolean = false ;				/**		 * Array of transitions associated with the last event called.		 */		private var eventTransitions : Array ;		/**		 * Event notification name called.		 */		private var eventCalled : String ;				/**		 * Array of condition notifications sent and awaiting results.		 */		private var conditionsSent : Array ;				/**		 * Map of condition results.		 */		private var conditionResults : Object ;				/**		 * The transition called as a result of an event call.		 */		private var transitionCalled : Transition ;				/**		 * The state that is currently exiting.		 */		private var exitingState : State ;				/**		 * Array of responders that have exited the exitingState.		 */		private var exitStateResponders : Array ;				/**		 * The action called as a result of an event call.		 */		private var actionCalled : String ;				/**		 * The state that is currently entering.		 */		private var enteringState : State ;				/**		 * Array of responders that have entered the enteringState.		 */		private var enterStateResponders : Array ;				//----------------------------------------------------------------------		//		//  Constructor		//		//----------------------------------------------------------------------		/**		 * Class constructor.		 */		public function StateProxy ( )		{			Log.stackTrace( this , "StateProxy" ) ;						super( StateProxy.NAME ) ;		}		//----------------------------------------------------------------------		//		//  Methods		//		//----------------------------------------------------------------------				/**		 * Registers an event with the StateEventCommand		 * 		 * @param event The event notification name. 		 */		public function registerEvent ( event : String ) : void		{			if ( !this.facade.hasCommand( event ) ) this.facade.registerCommand( event , StateEventCommand );		}				/**		 * Clears all existing states.		 */		public function clearStates () : void		{			Log.stackTrace( this , "clearStates" ) ;						if ( !this.busy )			{				// Resets just about everything.				this.states = null ;				this.initialState = null ;				this.currentState = null ;				this.eventTransitions = null ;				this.eventCalled = null ;				this.conditionsSent = null ;				this.conditionResults = null ;				this.transitionCalled = null ;				this.exitingState = null ;				this.exitStateResponders = null ;				this.actionCalled = null ;				this.enteringState = null ;				this.enterStateResponders = null ;			}		}		/**		 * Sets the initial states.		 * 		 * @param id The state identifier and notification name.		 */		public function setInitialState ( id : String ) : void		{			Log.stackTrace( this , "setInitialState", id ) ;						this.initialState = this.states[ id ] ;		}		/**		 * Gets the initial states.		 * 		 * @return The State instance.		 */		public function getInitialState () : State		{			return this.initialState ;		}		/**		 * Registers a new state with the state proxy.		 * 		 * @param id The state identifier and notification name.		 * @return The new State instance.		 */		public function createState ( id : String ) : State		{			Log.stackTrace( this , "createState", id ) ;						// Creates an empty state map if one doesn't exist.			if ( !this.states ) this.states = new Object() ;						// Creates the new state if it doesn't already exist.			if ( id == null || states[ id ] != null ) return null;			states[ id ] = new State( id, this ) ;						// Registers the state responder command to respond to the new state. 			this.facade.registerCommand( id , StateResponderCommand ) ;						// Returns the new state.			return states[ id ] as State ;		}		/**		 * Removes a state from the state proxy.		 * 		 * @param id The state identifier and notification name.		 */		public function removeState ( id : String ) : void		{			Log.stackTrace( this , "removeState", id ) ;						// Removes the state if it exists.			if ( states[ id ] ) this.facade.removeCommand( id ) ;			states[ id ] = null;		}		/**		 * Gets a registered state object by id. 		 * 		 * @param id The state identifier and notification name.		 * @return The State instance.		 */		public function getState ( id : String ) : State		{			return states[ id ] as State ;		}		/**		 * Gets the current state object.		 * 		 * @return The State instance.		 */		public function getCurrentState () : State		{			if ( !this.currentState ) this.currentState = this.initialState ;			return this.currentState ;		}		/**		 * Sets the current state object.		 * 		 * @param id The new state ID.		 */		private function setCurrentState ( id : String ) : void		{			Log.stackTrace( this , "setCurrentState", id ) ;						this.currentState = states[ id ] ;		}				//----------------------------------------------------------------------						/**		 * Calls a state machine event.		 * 		 * @param event The event notification name. 		 */		public function callEvent ( event : String ) : void		{			Log.stackTrace( this , "callEvent" , event ) ;						// Only proceed if a current state exists.			if ( this.getCurrentState() )			{				// Only proceed if the state proxy isn't busy processing another event.				if ( !this.busy )				{					// State proxy is now busy processing this event call.					this.busy = true ;					this.eventCalled = event ;										// Send event called notification.					this.sendNotification( StateProxy.EVENT_CALLED, this, event ) ;										// Check for event transitions.					this.eventTransitions = this.getCurrentState().getTransitionsByEvent( event ) ;					if ( this.eventTransitions.length > 0 )					{						// Create a list of conditions to test.						var conditions : Array = this.getConditions() ;												// If conditions exist, send conditions notifications and await response else proceed calling transitions.						if ( conditions.length > 0 )							this.sendConditionNotifications( conditions ) ;						else							this.callTransitions( this.eventTransitions ) ;					}					else					{						this.busy = false ;						this.eventError( "There is no transition associated with the event " + event + "." ) ;					}				}				else					this.eventError( "The state proxy is busy, so event " + event + " cannot be called." ) ;				}			else				this.eventError( "There is no current or initial state, so event " + event + " cannot be called." ) ;						}				/**		 * Calls state transitions triggered by and event after conditions are 		 * considered.		 * 		 * @param transitions An array of state transitions. 		 */		private function callTransitions ( transitions : Array ) : void		{			// Only proceed if there is just one transition.			if ( transitions.length == 1 )			{				// Sets the transition called and exits the current state.				this.transitionCalled = transitions[ 0 ] as Transition ;								this.exitCurrentState() ;			}			else if ( transitions.length > 1 )				this.eventError( "Error in state machine condition logic! More than one transition has been called by event " + this.eventCalled + "." ) ;			else 				this.eventError( "Error in state machine condition logic! No transition has been called by event " + this.eventCalled + "." ) ;		}				/**		 * Sends event error notifications.		 * 		 * @param error The error message.		 */		private function eventError ( error : String ) : void		{			Log.error( this , "eventError" , error ) ;						// Send event error notification with the error message as the type.			this.sendNotification( StateProxy.EVENT_ERROR, this, error ) ;		}				//----------------------------------------------------------------------				/**		 * Receives responses from transition condition commands.		 * 		 * @param condition The condition id.		 * @param result The result of the condition, true or false.		 */		public function conditionResponse ( condition : String, result : Boolean ) : void		{			Log.stackTrace( this , "conditionResult" , condition, result ) ;						if ( this.conditionResults[ condition ] == null ) this.conditionResults[ condition ] = result ;						for each ( var sentCondition : String in this.conditionsSent )				if ( this.conditionResults[ sentCondition ] == null ) return ;						this.testConditions() ;		}				/**		 * Gets the conditions to test for the called event's transitions.		 * 		 * @return An array of conditions with no duplicates.		 */		private function getConditions () : Array		{			Log.stackTrace( this , "getConditions" ) ;						var conditions : Array = [] ;			for each ( var transition : Transition in this.eventTransitions )				if ( transition.condition && conditions.indexOf( transition.condition ) == -1 )					conditions.push( transition.condition ) ;			return conditions ;		}				/**		 * Sends condition notifications to condition commands.		 * 		 * @param conditions An array of conditions.		 */		private function sendConditionNotifications ( conditions : Array ) : void		{			Log.stackTrace( this , "sendConditionNotifications", conditions ) ;						this.conditionsSent = conditions ;			this.conditionResults = new Object() ;						for each ( var condition : String in conditions )			{				Log.info( this , "sendConditionNotifications" , condition ) ;				this.sendNotification( condition ) ;			}		}				/**		 * Reduces the array of event transitions down to those that meet their 		 * conditions, then calls those transitions.		 */		private function testConditions () : void		{			Log.stackTrace( this , "testConditions" ) ;						for each ( var transition : Transition in this.eventTransitions )				if ( transition.condition ) 					if ( this.conditionResults [ transition.condition ] == transition.conditionInverse )						this.eventTransitions.splice( this.eventTransitions.indexOf( transition ), 1 ) ; 						this.callTransitions( this.eventTransitions ) ;		}				//----------------------------------------------------------------------				/**		 * Sends exit notification for the current state.		 */		private function exitCurrentState() : void		{			Log.stackTrace( this , "exitCurrentState", this.getCurrentState() ) ;						this.exitingState = this.getCurrentState() ;			this.exitStateResponders = [] ;			this.sendNotification( this.exitingState.id, this, StateProxy.EXIT ) ;		}		/**		 * Informs the proxy of a response to state exit notification.		 *		 * @param state The state identifier and notification name.		 * @param responder An IStateResponder instance.		 */		public function exitResponse ( state : String, responder : IStateResponder ) : void		{			Log.stackTrace( this , "exitResponse", state, responder ) ;						// Checks that the response is to the currently exiting state.			if ( this.getState( state ) == this.exitingState && this.exitStateResponders.indexOf( responder ) == -1 )			{				// Records the response.				this.exitStateResponders.push( responder ) ;								// Checks whether all the responders have responded. 				if ( this.exitingState.compareResponders( this.exitStateResponders ) )				{					Log.debug( this , "exitResponse", "Exited state " + this.getCurrentState().id ) ;										// Reset the exiting state.					this.exitingState = null ;					this.exitStateResponders = null ;										// If an action exists send the action notification, otherwise just enter the new state.					if ( this.transitionCalled.action )					{						this.actionCalled = this.transitionCalled.action ;						this.sendNotification( this.actionCalled, this.transitionCalled, this.getCurrentState().id ) ;					}					else						 this.enterNewState() ;				}			}		}				/**		 * Receives asynchrounous response from an action called by the current 		 * event transition.		 * 		 * @param action The action notification name.		 */		public function actionResponse ( action : String ) : void		{			// If the action responding is the action that was called, proceed to enter the new state.			if ( action == this.actionCalled )			{				this.actionCalled = null ;				this.enterNewState() ;			}		}				/**		 * Sends enter notification for the new state. 		 */		private function enterNewState() : void		{			Log.stackTrace( this , "enterNewState", this.transitionCalled.target ) ;						this.enteringState = this.getState( this.transitionCalled.target ) ;			this.enterStateResponders = [] ;			this.sendNotification( this.enteringState.id, this, StateProxy.ENTER ) ;		}				/**		 * Informs the proxy of a response to state enter notification.		 *		 * @param state The state identifier and notification name.		 * @param responder An IStateResponder instance.		 */		public function enterResponse ( state : String, responder : IStateResponder ) : void		{			Log.stackTrace( this , "enterResponse", state, responder ) ;						// Checks that the response is to the currently entering state.			if ( this.getState( state ) == this.enteringState && this.enterStateResponders.indexOf( responder ) == -1 )			{				// Records the response.				this.enterStateResponders.push( responder ) ;								// Checks whether all the responders have responded.				if ( this.enteringState.compareResponders( this.enterStateResponders ) )				{										Log.debug( this , "enterResponse", "State changed to " + this.enteringState.id ) ; 										// Set the new state as the current state.					this.setCurrentState( this.enteringState.id ) ;										// Reset the entering state and busy flag.					this.enteringState = null ;					this.enterStateResponders = null ;					this.busy = false ;										// Send event complete notification.					this.sendNotification( StateProxy.EVENT_COMPLETE, this , this.eventCalled ) ;				}			}		}			}}